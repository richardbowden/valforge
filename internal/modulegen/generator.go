package modulegen

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/richardbowden/valforge/internal/builder"
	"github.com/richardbowden/valforge/internal/project"
	"github.com/richardbowden/valforge/internal/vfcontext"
	"github.com/richardbowden/valforge/internal/vtypes"
)

type Generator struct {
	config      vtypes.GenerationConfig
	packagePath string
}

func NewGenerator(config vtypes.GenerationConfig) *Generator {
	g := &Generator{config: config}
	g.packagePath = g.getValforgePackagePath()

	return g
}

func (g *Generator) EnsurePackages(ctx *vfcontext.Context) error {
	if err := os.MkdirAll(g.packagePath, 0755); err != nil {
		return fmt.Errorf("failed to create error package directory: %w", err)
	}

	err := g.ensureErrorPackage()

	if err != nil {
		return fmt.Errorf("failed to create errors.go: %w", err)

	}

	err = g.ensureEmailValidation(ctx)
	if err != nil {
		return fmt.Errorf("failed to create email.go: %w", err)

	}
	return nil
}

func (g *Generator) ensureEmailValidation(ctx *vfcontext.Context) error {
	packagePath := g.getValforgePackagePath()
	emailValidationFile := filepath.Join(packagePath, "emailvalidation.gen.go")

	cb := builder.NewCodeBuilder()

	emailCode := `
func ValidateEmail(email string) error {
	// Check if email is empty
	if email == "" {
		return errors.New("email cannot be empty")
	}

	// Check for spaces
	if strings.Contains(email, " ") {
		return errors.New("email cannot contain spaces")
	}

	// Check for exactly one @ symbol
	atIndex := strings.Index(email, "@")
	if atIndex == -1 {
		return errors.New("email must contain an @ symbol")
	}

	if atIndex != strings.LastIndex(email, "@") {
		return errors.New("email cannot contain multiple @ symbols")
	}

	// Split into local and domain parts
	localPart := email[:atIndex]
	domainPart := email[atIndex+1:]

	// Check local part isn't empty
	if localPart == "" {
		return errors.New("email must have a local part before the @ symbol")
	}

	// Check domain part isn't empty
	if domainPart == "" {
		return errors.New("email must have a domain part after the @ symbol")
	}

	// Check domain contains at least one dot
	if !strings.Contains(domainPart, ".") {
		return errors.New("domain must contain at least one dot")
	}

	// Check that dot isn't first or last character in domain
	if strings.HasPrefix(domainPart, ".") {
		return errors.New("domain cannot start with a dot")
	}

	if strings.HasSuffix(domainPart, ".") {
		return errors.New("domain cannot end with a dot")
	}

	// Check there's content after the last dot (TLD)
	lastDotIndex := strings.LastIndex(domainPart, ".")
	if lastDotIndex == len(domainPart)-1 {
		return errors.New("domain must have a TLD after the last dot")
	}

	return nil
}
`

	cb.Writeln("// Code generated by valforge. DO NOT EDIT.")
	cb.Printf("// Version: %s", g.config.Version)
	cb.Printf("package %s", g.getValforgePackageName())
	cb.Newline()

	cb.Writeln("import (")
	cb.Indent()
	cb.Writeln(`"errors"`)
	cb.Writeln(`"strings"`)
	cb.Dedent()
	cb.Writeln(")")
	cb.Writeln(emailCode)

	if err := os.WriteFile(emailValidationFile, []byte(cb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write email file: %w", err)
	}

	return nil
}

func (g *Generator) ensureErrorPackage() error {
	errorsFile := filepath.Join(g.packagePath, "errors.gen.go")

	cb := builder.NewCodeBuilder()
	g.generateErrorPackage(cb)

	if err := os.WriteFile(errorsFile, []byte(cb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write errors file: %w", err)
	}

	fmt.Printf("âœ“ Generated validation errors in %s\n", errorsFile)
	return nil
}

func (g *Generator) GetImportPath() string {
	moduleName := g.config.ModuleName
	if moduleName == "" {
		// Try to find module name if not set
		if g.config.ProjectRoot != "" {
			_, foundModule, err := project.FindProjectRoot(g.config.ProjectRoot)
			if err == nil && foundModule != "" {
				moduleName = foundModule
			}
		}
	}

	if moduleName != "" {
		return fmt.Sprintf("%s/internal/%s", moduleName, g.getValforgePackageName())
	}

	// Fallback: still use full path format - user should set module name
	return fmt.Sprintf("./internal/%s", g.getValforgePackageName())
}

func (g *Generator) getValforgePackagePath() string {
	if g.config.ValforgePackagePath != "" {
		return g.config.ValforgePackagePath
	}
	return filepath.Join(g.config.ProjectRoot, "internal", g.getValforgePackageName())
}

func (g *Generator) getValforgePackageName() string {
	if g.config.ValforgePackage != "" {
		return g.config.ValforgePackage
	}
	return "valgen"
}

func (g *Generator) generateErrorPackage(cb *builder.CodeBuilder) {
	cb.Writeln("// Code generated by valforge. DO NOT EDIT.")
	cb.Printf("// Version: %s", g.config.Version)
	cb.Printf("package %s", g.getValforgePackageName())
	cb.Newline()

	cb.Writeln("import (")
	cb.Indent()
	cb.Writeln(`"encoding/json"`)
	cb.Writeln(`"fmt"`)
	cb.Writeln(`"strings"`)
	cb.Dedent()
	cb.Writeln(")")
	cb.Newline()

	// FieldError type
	cb.Writeln("type FieldError struct {")
	cb.Indent()
	cb.Writeln(`Field   string      ` + "`json:\"field\"`")
	cb.Writeln(`Message string      ` + "`json:\"message\"`")
	cb.Writeln(`Value   interface{} ` + "`json:\"value,omitempty\"`")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func (e FieldError) Error() string {")
	cb.Indent()
	cb.Writeln(`return fmt.Sprintf("%s: %s", e.Field, e.Message)`)
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	// ValidationError type
	cb.Writeln("type ValidationError struct {")
	cb.Indent()
	cb.Writeln(`Struct string       ` + "`json:\"struct\"`")
	cb.Writeln(`Errors []FieldError ` + "`json:\"errors\"`")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func (e *ValidationError) Error() string {")
	cb.Indent()
	cb.Writeln("if len(e.Errors) == 0 {")
	cb.Indent()
	cb.Writeln(`return fmt.Sprintf("%s validation failed", e.Struct)`)
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()
	cb.Writeln("if len(e.Errors) == 1 {")
	cb.Indent()
	cb.Writeln(`return fmt.Sprintf("%s validation failed: %s", e.Struct, e.Errors[0].Error())`)
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()
	cb.Writeln("var messages []string")
	cb.Writeln("for _, err := range e.Errors {")
	cb.Indent()
	cb.Writeln("messages = append(messages, err.Error())")
	cb.Dedent()
	cb.Writeln("}")
	cb.Writeln(`return fmt.Sprintf("%s validation failed: %s", e.Struct, strings.Join(messages, ", "))`)
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func (e *ValidationError) AddFieldError(field, message string, value interface{}) {")
	cb.Indent()
	cb.Writeln("e.Errors = append(e.Errors, FieldError{")
	cb.Indent()
	cb.Writeln("Field:   field,")
	cb.Writeln("Message: message,")
	cb.Writeln("Value:   value,")
	cb.Dedent()
	cb.Writeln("})")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func (e *ValidationError) JSON() ([]byte, error) {")
	cb.Indent()
	cb.Writeln("return json.Marshal(e)")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func (e *ValidationError) HasField(field string) bool {")
	cb.Indent()
	cb.Writeln("for _, f := range e.Errors {")
	cb.Indent()
	cb.Writeln("if f.Field == field {")
	cb.Indent()
	cb.Writeln("return true")
	cb.Dedent()
	cb.Writeln("}")
	cb.Dedent()
	cb.Writeln("}")
	cb.Writeln("return false")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	cb.Writeln("func NewValidationError(structName string) *ValidationError {")
	cb.Indent()
	cb.Writeln("return &ValidationError{")
	cb.Indent()
	cb.Writeln("Struct: structName,")
	cb.Writeln("Errors: make([]FieldError, 0),")
	cb.Dedent()
	cb.Writeln("}")
	cb.Dedent()
	cb.Writeln("}")
}
