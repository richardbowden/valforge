package generator

import (
	"bytes"
	"sort"
	"time"

	"github.com/richardbowden/valforge/internal/builder"
	"github.com/richardbowden/valforge/internal/modulegen"
	"github.com/richardbowden/valforge/internal/vtypes"
)

type Generator struct {
	registry    RuleRegistry
	config      vtypes.GenerationConfig
	moduleGen   *modulegen.Generator
	moduleAlias string
	genTime     time.Time
}

type RuleRegistry interface {
	GetRequiredImports(fields []vtypes.ValidationField) []string
	GetAllForGeneration() map[string]interface {
		Generate(*builder.CodeBuilder, vtypes.ValidationField, string) error
		Priority() int
	}
}

func New(registry RuleRegistry, config vtypes.GenerationConfig) *Generator {
	valforgePkgName := config.ValforgePackage
	if valforgePkgName == "" {
		valforgePkgName = "valgen"
	}

	return &Generator{
		registry:    registry,
		config:      config,
		moduleGen:   modulegen.NewGenerator(config),
		moduleAlias: valforgePkgName,
		genTime:     time.Now(),
	}
}

func (g *Generator) Generate(structs []vtypes.ValidationStruct) (string, error) {
	cb := builder.NewCodeBuilder()

	g.generateHeader(cb)
	g.generateImports(cb, structs)

	for _, s := range structs {
		if err := g.generateValidationMethod(cb, s); err != nil {
			return "", err
		}
	}

	return cb.String(), nil
}

func (g *Generator) getGenTime() string {
	var tzBuffer bytes.Buffer
	tzBuffer.WriteString("Generated at: ")
	tzBuffer.WriteString(g.genTime.Format("2006-01-02 15:04:05 -0700 MST"))

	return tzBuffer.String()
}

func (g *Generator) generateHeader(cb *builder.CodeBuilder) {
	cb.Writeln("// Code generated by valforge. DO NOT EDIT.")
	cb.Printf("// %s", g.getGenTime())
	cb.Printf("// Version: %s", g.config.Version)
	cb.Newline()
	cb.Printf("package %s", g.config.PackageName)
	cb.Newline()
}

func (g *Generator) generateImports(cb *builder.CodeBuilder, structs []vtypes.ValidationStruct) {
	var allFields []vtypes.ValidationField
	for _, s := range structs {
		allFields = append(allFields, s.Fields...)
	}

	imports := g.registry.GetRequiredImports(allFields)

	cb.Writeln("import (")
	cb.Indent()

	// Standard library imports
	for _, imp := range imports {
		cb.Printf(`"%s"`, imp)
	}
	cb.Newline()

	// Error package import
	errorImportPath := g.moduleGen.GetImportPath()
	cb.Printf(`%s "%s"`, g.moduleAlias, errorImportPath)

	cb.Dedent()
	cb.Writeln(")")
	cb.Newline()
}

func (g *Generator) generateValidationMethod(cb *builder.CodeBuilder, s vtypes.ValidationStruct) error {
	cb.Printf("func (v %s) Validate() error {", s.Name)
	cb.Indent()

	cb.Printf("verr := %s.NewValidationError(\"%s\")", g.moduleAlias, s.Name)
	cb.Newline()

	rules := g.registry.GetAllForGeneration()

	for _, field := range s.Fields {
		var applicableRules []interface {
			Generate(*builder.CodeBuilder, vtypes.ValidationField, string) error
			Priority() int
		}

		for ruleName := range field.Rules {
			if rule, exists := rules[ruleName]; exists {
				applicableRules = append(applicableRules, rule)
			}
		}

		sort.Slice(applicableRules, func(i, j int) bool {
			return applicableRules[i].Priority() < applicableRules[j].Priority()
		})

		for _, rule := range applicableRules {
			if err := rule.Generate(cb, field, s.Name); err != nil {
				return err
			}
		}
		cb.Newline()
	}

	cb.Printf("if len(verr.Errors) > 0 {")
	cb.Indent()
	cb.Writeln("return verr")
	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()
	cb.Writeln("return nil")

	cb.Dedent()
	cb.Writeln("}")
	cb.Newline()

	return nil
}
